from fastapi import Depends
from database.connection import get_db_connection
from database.transaction import db_transaction
from uuid import UUID

class ProveedorRepository:
    def __init__(self, db=Depends(get_db_connection)):
        self.db = db

    def listar_proveedores(self, empresa_id: UUID):
        if not self.db: return []
        with self.db.cursor() as cur:
            cur.execute(
                """
                SELECT * FROM proveedor 
                WHERE empresa_id = %s AND activo = TRUE
                ORDER BY created_at DESC
                """, 
                (str(empresa_id),)
            )
            return cur.fetchall()

    def obtener_proveedor_por_id(self, proveedor_id: UUID):
        if not self.db: return None
        with self.db.cursor() as cur:
            cur.execute("SELECT * FROM proveedor WHERE id = %s", (str(proveedor_id),))
            return cur.fetchone()

    def ruc_existe(self, ruc: str, empresa_id: UUID):
        if not self.db: return False
        with self.db.cursor() as cur:
            cur.execute(
                "SELECT id FROM proveedor WHERE ruc = %s AND empresa_id = %s", 
                (ruc, str(empresa_id))
            )
            return cur.fetchone() is not None

    def crear_proveedor(self, datos: dict):
        if not self.db: return None
        try:
            with db_transaction(self.db) as cur:
                # UUID is auto-generated by DB DEFAULT gen_random_uuid() usually, 
                # but if we want to return it, we use RETURNING *
                fields = ["empresa_id", "nombre", "ruc", "direccion", "telefono", "email", "activo"]
                values = [
                    str(datos.get("empresa_id")),
                    datos.get("nombre"),
                    datos.get("ruc"),
                    datos.get("direccion"),
                    datos.get("telefono"),
                    datos.get("email"),
                    datos.get("activo", True)
                ]
                
                query = f"""
                    INSERT INTO proveedor ({', '.join(fields)})
                    VALUES ({', '.join(['%s'] * len(fields))})
                    RETURNING *
                """
                cur.execute(query, tuple(values))
                return cur.fetchone()
        except Exception as e:
            print(f"Error creating provider: {e}")
            return {"error": str(e)}

    def actualizar_proveedor(self, proveedor_id: UUID, datos: dict):
        if not self.db: return None
        try:
            with db_transaction(self.db) as cur:
                fields = []
                params = []
                
                for key, value in datos.items():
                    if value is not None:
                        fields.append(f"{key} = %s")
                        params.append(value)
                
                fields.append("updated_at = NOW()")
                
                if not fields:
                    return None

                query = f"UPDATE proveedor SET {', '.join(fields)} WHERE id = %s RETURNING *"
                params.append(str(proveedor_id))
                
                cur.execute(query, tuple(params))
                return cur.fetchone()
        except Exception as e:
            print(f"Error updating provider: {e}")
            return {"error": str(e)}

    def eliminar_proveedor(self, proveedor_id: UUID):
        # Soft Delete usually preferred, but user schema says ON DELETE CASCADE/RESTRICT references.
        # User prompt SQL: "activo BOOLEAN DEFAULT TRUE". So Soft Delete implies setting activo=False.
        # But schema has ON DELETE constraints.
        # I will implement SOFT DELETE by setting activo = False, 
        # OR real delete if user wants "ELIMINAR". 
        # Permission is "PROVEEDOR_ELIMINAR".
        # Let's do Soft Delete ideally, but if I look at SQL schema, it has "activo".
        # I will do Soft Delete.
        if not self.db: return None
        try:
            with db_transaction(self.db) as cur:
                cur.execute(
                    "UPDATE proveedor SET activo = FALSE WHERE id=%s RETURNING *", 
                    (str(proveedor_id),)
                )
                return cur.fetchone()
        except Exception as e:
            print(f"Error deleting provider: {e}")
            return {"error": str(e)}
